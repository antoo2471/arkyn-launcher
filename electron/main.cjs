const { app, BrowserWindow, ipcMain, dialog } = require('electron');
const path = require('path');
const os = require('os');
const { autoUpdater } = require('electron-updater');
const { Launch } = require('minecraft-java-core');
const { AuthManager, AuthManagerError } = require('./auth/AuthManager.cjs');
const richPresence = require('discord-rich-presence')('1470506574492467417'); // Discord Application ID
const { spawn } = require('child_process');

// Get user data directory (AppData/Roaming on Windows)
app.setPath('userData', path.join(app.getPath('appData'), 'Arkyn Launcher'));
const userDataPath = app.getPath('userData');
const gamesPath = path.join(userDataPath, 'games');
const authManager = new AuthManager({
    storageDir: userDataPath,
    microsoftClientId: process.env.MICROSOFT_CLIENT_ID,
    microsoftRedirectUri: process.env.MICROSOFT_REDIRECT_URI
});

// ... (rest of imports)

// Ensure games directory exists
const fs = require('fs');
if (!fs.existsSync(gamesPath)) {
    fs.mkdirSync(gamesPath, { recursive: true });
}

// Handler to give the path to the renderer
ipcMain.handle('get-games-path', () => {
    return gamesPath;
});

console.log('Launcher data path:', userDataPath);
console.log('Games path:', gamesPath);

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
    app.quit();
}

let mainWindow;
let splashWindow;
let logWindow;
let currentGameProcess = null;
let modsGuardTimer = null;
let isGuardCheckRunning = false;
let guardTriggered = false;
let guardConfig = null;
let guardPhase = 'idle';
let volatileAccount = null;
let updaterState = {
    enabled: false,
    status: 'idle',
    message: 'Mise a jour en attente',
    currentVersion: app.getVersion(),
    latestVersion: null,
    progressPercent: 0
};
let releaseMainWindowTimer = null;
let mainWindowReleased = false;
let updaterGateStartedAt = Date.now();

const MIN_UPDATER_SPLASH_MS = 3000;

function publishUpdaterState() {
    if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('updater-state', updaterState);
    }
    if (splashWindow && !splashWindow.isDestroyed()) {
        splashWindow.webContents.send('updater-state', updaterState);
    }
}

function releaseMainWindowIfAllowed() {
    if (mainWindowReleased) return;
    if (!mainWindow || mainWindow.isDestroyed()) return;
    const allowed = updaterState.status === 'up-to-date' || updaterState.status === 'disabled';
    if (!allowed) return;

    if (releaseMainWindowTimer) {
        clearTimeout(releaseMainWindowTimer);
    }

    const elapsed = Date.now() - updaterGateStartedAt;
    const waitMs = Math.max(0, MIN_UPDATER_SPLASH_MS - elapsed);

    releaseMainWindowTimer = setTimeout(() => {
        if (mainWindowReleased) return;
        mainWindowReleased = true;

        if (splashWindow && !splashWindow.isDestroyed()) {
            splashWindow.close();
        }

        if (mainWindow && !mainWindow.isDestroyed()) {
            mainWindow.show();
            mainWindow.focus();
        }
    }, waitMs);
}

function setUpdaterState(patch) {
    updaterState = { ...updaterState, ...patch };
    publishUpdaterState();
    releaseMainWindowIfAllowed();
}

function parseBooleanEnv(value) {
    const normalized = String(value ?? '').trim().toLowerCase();
    return ['1', 'true', 'yes', 'on'].includes(normalized);
}

function resolveGithubUpdaterConfig() {
    const owner = process.env.ARKYN_UPDATER_GH_OWNER || process.env.GH_OWNER;
    const repo = process.env.ARKYN_UPDATER_GH_REPO || process.env.GH_REPO;
    if (!owner || !repo) return null;

    const privateRepo = parseBooleanEnv(process.env.ARKYN_UPDATER_PRIVATE);
    const token = process.env.ARKYN_UPDATER_GH_TOKEN || process.env.GH_TOKEN || process.env.GITHUB_TOKEN;

    const config = {
        provider: 'github',
        owner,
        repo,
        private: privateRepo
    };

    if (privateRepo && token) {
        config.token = token;
    }

    return config;
}

function setupAutoUpdater() {
    if (!app.isPackaged) {
        setUpdaterState({
            enabled: false,
            status: 'disabled',
            message: 'Auto-updater desactive en mode developpement'
        });
        return;
    }

    const feedConfig = resolveGithubUpdaterConfig();
    autoUpdater.autoDownload = false;
    autoUpdater.autoInstallOnAppQuit = true;
    autoUpdater.allowPrerelease = false;

    // If env vars are provided, they override embedded builder publish config.
    // Otherwise autoUpdater uses app-update.yml generated by electron-builder.
    if (feedConfig) {
        autoUpdater.setFeedURL(feedConfig);
    }

    autoUpdater.on('checking-for-update', () => {
        setUpdaterState({
            enabled: true,
            status: 'checking',
            message: 'Verification des mises a jour...'
        });
    });

    autoUpdater.on('update-available', (info) => {
        setUpdaterState({
            enabled: true,
            status: 'available',
            latestVersion: info?.version || null,
            message: `Version ${info?.version || 'plus recente'} disponible`,
            progressPercent: 0
        });
    });

    autoUpdater.on('update-not-available', () => {
        setUpdaterState({
            enabled: true,
            status: 'up-to-date',
            latestVersion: null,
            message: 'Launcher deja a jour',
            progressPercent: 0
        });
    });

    autoUpdater.on('download-progress', (progressObj = {}) => {
        setUpdaterState({
            enabled: true,
            status: 'downloading',
            progressPercent: Math.round(progressObj.percent || 0),
            message: `Telechargement de la mise a jour: ${Math.round(progressObj.percent || 0)}%`
        });
    });

    autoUpdater.on('update-downloaded', (info) => {
        setUpdaterState({
            enabled: true,
            status: 'downloaded',
            latestVersion: info?.version || updaterState.latestVersion,
            progressPercent: 100,
            message: 'Mise a jour prete. Redemarre le launcher pour installer.'
        });
    });

    autoUpdater.on('error', (error) => {
        setUpdaterState({
            enabled: true,
            status: 'error',
            message: error?.message || 'Erreur auto-updater',
            progressPercent: 0
        });
    });

    setUpdaterState({
        enabled: true,
        status: 'idle',
        message: feedConfig ? 'Auto-updater actif (config env)' : 'Auto-updater actif',
        progressPercent: 0
    });

    setTimeout(() => {
        autoUpdater.checkForUpdates().catch((error) => {
            setUpdaterState({
                enabled: true,
                status: 'error',
                message: error?.message || 'Verification impossible'
            });
        });
    }, 200);
}

// Discord Rich Presence functions
function updateDiscordPresence(details, state, largeImageKey = 'arkyn_logo', smallImageKey = null, smallImageText = null) {
    if (!richPresence) return;
    
    const presence = {
        details: details,
        state: state,
        largeImageKey: largeImageKey,
        largeImageText: 'Arkyn Launcher',
        instance: true
    };
    
    if (smallImageKey) {
        presence.smallImageKey = smallImageKey;
        presence.smallImageText = smallImageText;
    }
    
    richPresence.updatePresence(presence);
    console.log('[Discord] Presence updated:', { details, state });
}

function clearDiscordPresence() {
    if (richPresence) {
        richPresence.updatePresence({
            details: null,
            state: null,
            largeImageKey: null,
            smallImageKey: null,
            instance: false
        });
        console.log('[Discord] Presence cleared');
    }
}

function hashFileSha1(filePath) {
    const fileBuffer = fs.readFileSync(filePath);
    const hashSum = crypto.createHash('sha1');
    hashSum.update(fileBuffer);
    return hashSum.digest('hex');
}

function isJarFileName(fileName = '') {
    return String(fileName).toLowerCase().endsWith('.jar');
}

function killProcessTree(pid) {
    if (!pid) return;
    if (process.platform === 'win32') {
        spawn('taskkill', ['/pid', String(pid), '/f', '/t'], { windowsHide: true });
        return;
    }
    try {
        process.kill(-pid, 'SIGKILL');
    } catch (_) {
        try {
            process.kill(pid, 'SIGKILL');
        } catch (_) {
            // ignore
        }
    }
}

function stopModsGuard() {
    if (modsGuardTimer) {
        clearTimeout(modsGuardTimer);
        modsGuardTimer = null;
    }
    isGuardCheckRunning = false;
    guardTriggered = false;
    guardConfig = null;
    guardPhase = 'idle';
    console.log('[StrixAC - Layer 1] Mods guard stopped');
}

function stopGameProcess(reason = 'manual') {
    if (!currentGameProcess || currentGameProcess.killed) return;
    console.warn(`[StrixAC - Layer 1] Stopping game process (${reason})`);
    killProcessTree(currentGameProcess.pid);
}

async function enforceModsIntegrity({ gamePath, expectedMods }) {
    if (!gamePath || !Array.isArray(expectedMods)) return { ok: true };

    const modsDir = path.join(gamePath, 'mods');
    if (!fs.existsSync(modsDir)) {
        return { ok: expectedMods.length === 0 };
    }

    const expectedMap = new Map();
    for (const mod of expectedMods) {
        if (!mod || !mod.name || !mod.sha1 || !isJarFileName(mod.name)) continue;
        expectedMap.set(mod.name, String(mod.sha1).toLowerCase());
    }

    const localFiles = fs.readdirSync(modsDir, { withFileTypes: true })
        .filter(entry => entry.isFile() && isJarFileName(entry.name))
        .map(entry => entry.name);

    for (const localFile of localFiles) {
        if (!expectedMap.has(localFile)) {
            return { ok: false, reason: `Extra mod detected: ${localFile}` };
        }
    }

    for (const [modName, expectedSha1] of expectedMap.entries()) {
        const modPath = path.join(modsDir, modName);
        if (!fs.existsSync(modPath)) {
            return { ok: false, reason: `Missing mod detected: ${modName}` };
        }
        try {
            const fileSha1 = hashFileSha1(modPath).toLowerCase();
            if (fileSha1 !== expectedSha1) {
                return { ok: false, reason: `Hash mismatch detected: ${modName}` };
            }
        } catch (error) {
            return { ok: false, reason: `Hash error on ${modName}: ${error.message}` };
        }
    }

    return { ok: true };
}

function isGameWindowLikelyShown(logData = '') {
    const line = String(logData).toLowerCase();
    return (
        line.includes('setting user:') ||
        line.includes('lwjgl version') ||
        line.includes('backend library: lwjgl') ||
        line.includes('render thread') ||
        line.includes('successfully loaded')
    );
}

async function runGuardCheckNow() {
    if (!guardConfig || guardTriggered || isGuardCheckRunning) return;
    isGuardCheckRunning = true;
    try {
        const check = await enforceModsIntegrity(guardConfig);
        if (!check.ok && !guardTriggered) {
            guardTriggered = true;
            console.error(`[StrixAC - Layer 1][${guardPhase}] Integrity check failed:`, check.reason);
            stopGameProcess(`integrity_check_failed_${guardPhase}`);
            await dialog.showMessageBox({
                type: 'error',
                title: 'Arkyn Launcher',
                message: 'Modification du jeu détécté, arrêt'
            });
        } else {
            console.log(`[StrixAC - Layer 1][${guardPhase}] Check OK`);
        }
    } catch (error) {
        console.error('[StrixAC - Layer 1] Integrity check error:', error);
    } finally {
        isGuardCheckRunning = false;
    }
}

function scheduleNextGuardTick() {
    if (!guardConfig || guardTriggered) return;
    const delay = guardPhase === 'boot' ? 250 : 30000;
    modsGuardTimer = setTimeout(async () => {
        await runGuardCheckNow();
        scheduleNextGuardTick();
    }, delay);
}

function startModsGuard({ gamePath, expectedMods }) {
    stopModsGuard();
    if (!gamePath || !Array.isArray(expectedMods)) return;
    guardConfig = { gamePath, expectedMods };
    guardPhase = 'boot';
    console.log('[StrixAC - Layer 1] Mods guard started in BOOT mode (250ms)');
    runGuardCheckNow();
    scheduleNextGuardTick();
}

function switchModsGuardToNormalMode() {
    if (!guardConfig || guardTriggered) return;
    if (guardPhase === 'normal') return;
    guardPhase = 'normal';
    if (modsGuardTimer) {
        clearTimeout(modsGuardTimer);
        modsGuardTimer = null;
    }
    console.log('[StrixAC - Layer 1] Game window detected -> switching to NORMAL mode (30s)');
    scheduleNextGuardTick();
}

function createLogWindow() {
    console.log('[Main] createLogWindow called');
    if (logWindow) {
        console.log('[Main] Log window already exists, focusing');
        logWindow.focus();
        return logWindow;
    }

    console.log('[Main] Creating new log window');
    logWindow = new BrowserWindow({
        width: 800,
        height: 600,
        backgroundColor: '#0c0c0c',
        title: "Minecraft Logs",
        icon: path.join(__dirname, '..', 'icon.png'), // Same icon for log window
        webPreferences: {
            nodeIntegration: false,
            contextIsolation: true,
            enableRemoteModule: false,
            webSecurity: true,
            sandbox: false,
            preload: path.join(__dirname, 'preload.cjs')
        },
        autoHideMenuBar: true,
        frame: false
    });

    const startUrl = process.env.ELECTRON_START_URL
        ? process.env.ELECTRON_START_URL
        : `file://${path.join(__dirname, '../dist/index.html')}`;

    logWindow.loadURL(startUrl + '#logs');

    // Wait for window to load then setup communication
    logWindow.webContents.once('did-finish-load', () => {
        console.log('[Main] Log window finished loading');
    });

    if (process.env.ELECTRON_START_URL) {
        // logWindow.webContents.openDevTools({ mode: 'detach' });
    }

    logWindow.on('closed', () => {
        logWindow = null;
    });

    return logWindow;
}

function createWindow() {
    const preloadPath = path.join(__dirname, 'preload.cjs');

    mainWindow = new BrowserWindow({
        width: 1280,
        height: 720,
        backgroundColor: '#1a1a1a',
        title: "Arkyn Studios",
        icon: path.join(__dirname, '..', 'icon.png'), // Path to icon.png in frontend root
        webPreferences: {
            nodeIntegration: false,
            contextIsolation: true,
            enableRemoteModule: false,
            webSecurity: true,
            sandbox: false,
            preload: preloadPath
        },
        autoHideMenuBar: true,
        frame: false,
        show: false
    });

    ipcMain.on('window-minimize', () => {
        mainWindow.minimize();
    });

    ipcMain.on('window-maximize', () => {
        if (mainWindow.isMaximized()) {
            mainWindow.unmaximize();
        } else {
            mainWindow.maximize();
        }
    });

    ipcMain.on('window-close', () => {
        mainWindow.close();
    });

    ipcMain.on('open-log-window', () => {
        const logWin = createLogWindow();
    });

    ipcMain.on('close-log-window', () => {
        if (logWindow) {
            logWindow.close();
        }
    });

    const startUrl = process.env.ELECTRON_START_URL
        ? process.env.ELECTRON_START_URL
        : `file://${path.join(__dirname, '../dist/index.html')}`;

    mainWindow.loadURL(startUrl);

    // DevTools in development
    // if (!app.isPackaged) {
    //    mainWindow.webContents.openDevTools({ mode: 'detach' });
    // }

    mainWindow.on('closed', () => {
        stopGameProcess('launcher_window_closed');
        mainWindow = null;
    });
    
    // Initialize Discord Rich Presence when launcher starts
    updateDiscordPresence('Dans le launcher', 'Prêt à jouer', 'arkyn_logo', 'idle', 'En attente');
}

function createSplashWindow() {
    splashWindow = new BrowserWindow({
        width: 380,
        height: 450,
        frame: false,
        resizable: false,
        minimizable: false,
        maximizable: false,
        fullscreenable: false,
        alwaysOnTop: true,
        autoHideMenuBar: true,
        backgroundColor: '#0d0d14',
        icon: path.join(__dirname, '..', 'icon.png'),
        webPreferences: {
            nodeIntegration: false,
            contextIsolation: true,
            enableRemoteModule: false,
            webSecurity: true,
            sandbox: false,
            preload: path.join(__dirname, 'preload.cjs')
        }
    });

    splashWindow.loadURL(`file://${path.join(__dirname, 'splash.html')}`);
    splashWindow.on('closed', () => {
        splashWindow = null;
        if (!mainWindowReleased) {
            app.quit();
        }
    });
}

app.whenReady().then(() => {
    updaterGateStartedAt = Date.now();
    mainWindowReleased = false;
    createSplashWindow();
    createWindow();
    setupAutoUpdater();
});

app.on('window-all-closed', () => {
    stopModsGuard();
    stopGameProcess('all_windows_closed');
    clearDiscordPresence();
    app.quit();
});

app.on('before-quit', () => {
    stopModsGuard();
    stopGameProcess('launcher_quit');
    clearDiscordPresence();
});

app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
        createWindow();
    }
});

// --- IPC Handlers for Launcher Logic ---
const crypto = require('crypto');
const https = require('https');
const http = require('http');
const { URL } = require('url');

function downloadFile(url, dest, redirectDepth = 0) {
    console.log('[Main] downloadFile', url);
    return new Promise((resolve, reject) => {
        const file = fs.createWriteStream(dest);
        const protocol = url.startsWith('https') ? https : http;
        protocol.get(url, (response) => {
            // Follow redirect if needed
            if (response.statusCode >= 300 && response.statusCode < 400 && response.headers.location) {
                if (redirectDepth >= 5) {
                    fs.unlink(dest, () => reject(new Error('Too many redirects')));
                    return;
                }
                const nextUrl = new URL(response.headers.location, url).toString();
                response.resume(); // discard
                file.close();
                return resolve(downloadFile(nextUrl, dest, redirectDepth + 1));
            }

            if (response.statusCode !== 200) {
                fs.unlink(dest, () => reject(new Error(`Failed to download: ${response.statusCode}`)));
                return;
            }
            response.pipe(file);
            file.on('finish', () => {
                file.close(resolve);
            });
        }).on('error', (err) => {
            fs.unlink(dest, () => reject(err));
        });
    });
}

ipcMain.handle('sync-mods', async (event, { mods, gameFolder }) => {
    console.log('[Main] Syncing mods for:', gameFolder);
    const modsDir = path.join(gamesPath, gameFolder, 'mods');

    if (!fs.existsSync(modsDir)) {
        fs.mkdirSync(modsDir, { recursive: true });
    }

    const localFiles = fs.readdirSync(modsDir, { withFileTypes: true })
        .filter(entry => entry.isFile() && isJarFileName(entry.name))
        .map(entry => entry.name);
    const remoteNames = mods.map(m => m.name).filter(isJarFileName);

    // 1. Remove extras
    for (const file of localFiles) {
        if (!remoteNames.includes(file)) {
            try {
                fs.unlinkSync(path.join(modsDir, file));
                console.log('Removed old mod:', file);
            } catch (error) {
                console.warn('Could not delete file, skipping:', file, error.message);
            }
        }
    }

    // 2. Identify missing/mismatch
    const toDownload = [];
    for (const mod of mods) {
        if (!isJarFileName(mod?.name)) continue;
        const modPath = path.join(modsDir, mod.name);
        let shouldDownload = true;

        if (fs.existsSync(modPath)) {
            try {
                const fileBuffer = fs.readFileSync(modPath);
                const hashSum = crypto.createHash('sha1');
                hashSum.update(fileBuffer);
                const hex = hashSum.digest('hex');
                if (hex === mod.sha1) {
                    shouldDownload = false;
                }
            } catch (e) {
                console.error("Error hashing file:", e);
                shouldDownload = true; // Redownload on error
            }
        }

        if (shouldDownload) {
            toDownload.push(mod);
        }
    }

    // 3. Download
    let downloaded = 0;
    const total = toDownload.length;

    // Notify start
    event.sender.send('mods-progress', { current: 0, total: total > 0 ? total : 1 });

    for (const mod of toDownload) {
        const modPath = path.join(modsDir, mod.name);
        console.log('Downloading mod:', mod.name);

        try {
            await downloadFile(mod.url, modPath);
            downloaded++;
            event.sender.send('mods-progress', { current: downloaded, total });
        } catch (e) {
            console.error("Failed to download mod:", mod.name, e);
        }
    }

    return { success: true };
});

ipcMain.handle('updater-get-state', async () => {
    return updaterState;
});

ipcMain.handle('updater-check', async () => {
    if (!updaterState.enabled) return updaterState;
    try {
        await autoUpdater.checkForUpdates();
    } catch (error) {
        setUpdaterState({
            status: 'error',
            message: error?.message || 'Verification impossible'
        });
    }
    return updaterState;
});

ipcMain.handle('updater-download', async () => {
    if (!updaterState.enabled) return updaterState;
    if (updaterState.status !== 'available' && updaterState.status !== 'downloading') {
        return updaterState;
    }
    try {
        await autoUpdater.downloadUpdate();
    } catch (error) {
        setUpdaterState({
            status: 'error',
            message: error?.message || 'Telechargement impossible'
        });
    }
    return updaterState;
});

ipcMain.handle('updater-install', async () => {
    if (!updaterState.enabled) return updaterState;
    if (updaterState.status !== 'downloaded') return updaterState;
    autoUpdater.quitAndInstall(false, true);
    return updaterState;
});

ipcMain.handle('launch-game', async (event, options) => {
    console.log('[Main] Launch requested:', {
        path: options?.path,
        version: options?.version,
        hasExpectedMods: Array.isArray(options?.expectedMods)
    });
    const expectedMods = options.expectedMods || [];
    const gamePath = options.path;
    
    // Create log window if it doesn't exist
    if (!logWindow || logWindow.isDestroyed()) {
        console.log('[Main] Creating log window before game launch');
        createLogWindow();
        
        // Wait a bit for the log window to be ready
        await new Promise(resolve => setTimeout(resolve, 1000));
    }
    
    // Update Discord presence when game starts launching
    updateDiscordPresence('Lancement du jeu', 'Chargement en cours...', 'arkyn_logo', 'loading', 'Lancement');
    
    const launcher = new Launch();

    launcher.on('data', (data) => {
        // Convert data to string properly
        let logData;
        if (typeof data === 'string') {
            logData = data;
        } else if (data && data.toString) {
            logData = data.toString();
        } else {
            logData = String(data || '');
        }
        
        if (logData.trim()) { // Only send non-empty data
            console.log('[Main] Sending log data:', logData.substring(0, 100) + '...');
            if (guardPhase === 'boot' && isGameWindowLikelyShown(logData)) {
                switchModsGuardToNormalMode();
            }
            if (logWindow && !logWindow.isDestroyed()) {
                logWindow.webContents.send('launcher-data', logData);
                console.log('[Main] Sent to log window');
            } else {
                console.log('[Main] Log window not available');
            }
            if (mainWindow && !mainWindow.isDestroyed()) {
                mainWindow.webContents.send('launcher-data', logData);
                console.log('[Main] Sent to main window');
            }
        }
    });

    launcher.on('progress', (progress, size) => {
        if (mainWindow && !mainWindow.isDestroyed()) {
            // Send progress to main window
            mainWindow.webContents.send('launcher-progress', { progress, size });
        }
    });

    launcher.on('close', (code) => {
        stopModsGuard();
        currentGameProcess = null;
        // Update Discord presence when game closes
        updateDiscordPresence('Dans le launcher', 'Prêt à jouer', 'arkyn_logo', 'idle', 'En attente');
        
        if (mainWindow && !mainWindow.isDestroyed()) {
            mainWindow.webContents.send('launcher-close', code);
        }
        if (logWindow && !logWindow.isDestroyed()) {
            logWindow.webContents.send('launcher-close', code);
        }
    });

    try {
        // Always validate/refresh account in the trusted main process before launch.
        const usingVolatileAccount = !!volatileAccount;
        const authenticator = usingVolatileAccount
            ? await authManager.refreshIfNeeded({ account: volatileAccount, persist: false })
            : await authManager.refreshIfNeeded();

        if (usingVolatileAccount) {
            volatileAccount = authManager.normalizeAuthenticator(authenticator);
        }

        // Pre-check immediately before starting Java to catch last-second tampering.
        const preLaunchCheck = await enforceModsIntegrity({ gamePath, expectedMods });
        if (!preLaunchCheck.ok) {
            console.error('[StrixAC - Layer 1][prelaunch] Integrity check failed:', preLaunchCheck.reason);
            await dialog.showMessageBox({
                type: 'error',
                title: 'Arkyn Launcher',
                message: 'Modification du jeu détécté, arrêt'
            });
            return { success: false, error: 'Modification détectée avant lancement.' };
        }

        // Start rapid guard immediately for the full bootstrap phase.
        startModsGuard({
            gamePath,
            expectedMods
        });

        const launchOptions = {
            ...options,
            authenticator
        };

        const process = await launcher.Launch(launchOptions);
        if (!process || !process.pid) {
            throw new Error('Impossible de suivre le process du jeu.');
        }
        currentGameProcess = process;
        console.log('[StrixAC - Layer 1] Game process attached:', currentGameProcess.pid);

        if (guardTriggered) {
            console.warn('[StrixAC - Layer 1] Tampering was detected during bootstrap, killing game immediately');
            stopGameProcess('bootstrap_detection_after_spawn');
            return { success: false, error: 'Modification détectée pendant le lancement.' };
        }

        if (currentGameProcess && typeof currentGameProcess.on === 'function') {
            currentGameProcess.on('exit', () => {
                stopModsGuard();
                currentGameProcess = null;
            });
        }

        // Determine which Arkyn server is being played
        let serverName = 'Arkyn';
        const launchPath = options.path || '';
        const serverIP = options.quickPlay?.identifier || '';
        
        if (launchPath.includes('nations') || serverIP.includes('nations')) {
            serverName = 'Arkyn Nations';
        } else if (launchPath.includes('crazytown') || serverIP.includes('crazytown')) {
            serverName = 'Arkyn CrazyTown';
        } else if (launchPath.includes('faction') || serverIP.includes('faction')) {
            serverName = 'Arkyn PvP Faction';
        } else if (launchPath.includes('modde') || serverIP.includes('modde')) {
            serverName = 'Arkyn Moddé';
        } else if (launchPath.includes('minigames') || serverIP.includes('minigames')) {
            serverName = 'Arkyn Minigames';
        }
        
        const playerName = authenticator?.name || 'Joueur';
        
        // Update Discord presence with specific Arkyn server
        updateDiscordPresence(
            `Joue à ${serverName}`, 
            `${playerName} est en jeu`, 
            'minecraft', 
            'playing', 
            'En jeu'
        );
        
        return { success: true };
    } catch (error) {
        if (error instanceof AuthManagerError) {
            if (error.code === 'AUTH_REQUIRED' || error.code === 'AUTH_RELOGIN_REQUIRED') {
                volatileAccount = null;
            }
            updateDiscordPresence('Dans le launcher', 'Prêt à jouer', 'arkyn_logo', 'idle', 'En attente');
            if (error.code === 'AUTH_REQUIRED' || error.code === 'AUTH_RELOGIN_REQUIRED') {
                return {
                    success: false,
                    code: 'AUTH_REQUIRED',
                    error: 'Session Microsoft expirée ou invalide. Merci de vous reconnecter.'
                };
            }

            if (error.code === 'NETWORK_ERROR') {
                return {
                    success: false,
                    code: 'NETWORK_ERROR',
                    error: 'Impossible de vérifier votre session Microsoft (réseau indisponible).'
                };
            }
        }

        console.error('Launch error:', error);
        // Reset to launcher state on error
        updateDiscordPresence('Dans le launcher', 'Prêt à jouer', 'arkyn_logo', 'idle', 'En attente');
        return { success: false, error: error.message };
    }
});

ipcMain.handle('microsoft-session', async () => {
    try {
        // Do not auto-login from remembered accounts anymore. The renderer now shows profile picker.
        if (!volatileAccount) return { success: false };
        return { success: true, result: authManager.getPublicAccount(volatileAccount), rememberMe: false };
    } catch (error) {
        return { success: false, error: error.message || 'Erreur inconnue' };
    }
});

ipcMain.handle('microsoft-accounts', async () => {
    try {
        const accounts = await authManager.listAccounts();
        return { success: true, accounts };
    } catch (error) {
        return { success: false, accounts: [], error: error.message || 'Erreur inconnue' };
    }
});

ipcMain.handle('microsoft-select-account', async (event, payload = {}) => {
    try {
        const account = await authManager.selectAccount(payload?.uuid);
        volatileAccount = null;
        return { success: true, result: authManager.getPublicAccount(account) };
    } catch (error) {
        if (error instanceof AuthManagerError && error.code === 'ACCOUNT_NOT_FOUND') {
            return { success: false, error: 'Compte introuvable.' };
        }
        return { success: false, error: error.message || 'Erreur inconnue' };
    }
});

ipcMain.handle('microsoft-forget-account', async (event, payload = {}) => {
    try {
        const uuid = payload?.uuid;
        if (!uuid) {
            return { success: false, error: 'UUID manquant.' };
        }

        await authManager.clearAccount(uuid);

        // Keep volatile account only if it is not the removed one.
        if (volatileAccount && volatileAccount.uuid === uuid) {
            volatileAccount = null;
        }

        const accounts = await authManager.listAccounts();
        return { success: true, accounts };
    } catch (error) {
        return { success: false, error: error.message || 'Erreur inconnue' };
    }
});

ipcMain.handle('microsoft-login', async (event, payload = {}) => {
    try {
        const rememberMe = payload?.rememberMe === true;

        const account = await authManager.login({ persist: rememberMe });
        volatileAccount = rememberMe ? null : account;
        return { success: true, result: authManager.getPublicAccount(account) };
    } catch (error) {
        if (error instanceof AuthManagerError) {
            if (error.code === 'AUTH_CANCELLED') {
                return { success: false, error: 'Connexion annulée' };
            }
            if (error.code === 'NETWORK_ERROR') {
                return { success: false, error: 'Impossible de contacter les services Microsoft (réseau).' };
            }
            return { success: false, error: error.message };
        }

        return { success: false, error: error.message };
    }
});

ipcMain.handle('microsoft-logout', async () => {
    try {
        volatileAccount = null;
        return { success: true };
    } catch (error) {
        return { success: false, error: error.message || 'Erreur inconnue' };
    }
});
